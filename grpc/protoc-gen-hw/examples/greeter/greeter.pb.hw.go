// Code generated by protoc-gen-hw. DO NOT EDIT.
// source: greeter.proto

package greeter

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	math "math"
)

import (
	context "context"
	pkg "git.huoys.com/kit/gomsg/pkg"
	server "git.huoys.com/kit/gomsg/pkg/ws/server"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// Reference imports to suppress errors if they are not otherwise used.
var _ pkg.IRet
var _ context.Context
var _ server.Server

type GreeterWsServer interface {
	StartNotify(ws *server.Server)
	Hello(ctx context.Context, req *Request) (resp *Response, err error)
}

var srv GreeterServer

type shandler struct {
	closeChan chan string
}

func (h *shandler) OnOpen(p pkg.Session) {}
func (h *shandler) OnClose(p pkg.Session, b bool) {
	h.closeChan <- fmt.Sprint(p.ID())
}

func (h *shandler) OnReq(pk pkg.Session, data []byte) pkg.IRet {
	var (
		pb  Message
		ctx = context.WithValue(context.Background(), "id", pk.ID())
	)
	err := proto.Unmarshal(data, &pb)
	if err != nil {
		return nil
	}
	switch pb.Ops {
	case int32(GameCommand_Hello):
		var req = &Request{}
		if err = proto.Unmarshal(pb.Data, req); err != nil {
			return pkg.Error(int16(pkg.ReadErrorNo), err.Error())
		}
		resp, err := srv.Hello(ctx, req)
		if err != nil {
			return pkg.Error(int16(pkg.Write), err.Error())
		}
		res, _ := proto.Marshal(resp)
		return pkg.Ok(res)
	default:
		return pkg.Error(int16(pkg.NoHandler), "not implemented")
	}
}

func (h *shandler) OnPush(pk pkg.Session, data []byte) pkg.IRet {
	return pkg.Ok(nil)
}

func RegisterDemoWsServer(e *server.Server, addr string, closeChan chan string, s GreeterServer) error {
	srv = s
	return e.ListenAndServe(addr, &shandler{closeChan: closeChan})
}
